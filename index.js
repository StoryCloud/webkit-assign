'use strict';

var _ = require('lodash');
var async = require('async');
var escodegen = require('escodegen');
var esprima = require('esprima');
var fs = require('graceful-fs');
var path = require('path');

/**
 * Extension to append to files to distinguish them from their original
 * versions.
 */
var SUBEXTENSION = '.webkitassign';

/**
 * Super-duper secret namespace for variables generated by this package.
 */
var NAMESPACE = '__webkitAssign__';

/**
 * Returns `file` with a subextension (to avoid overwriting that file).
 */
var getOutputFile = function (file) {
    var directory = path.dirname(file);
    var base = path.basename(file);
    var extension = path.extname(file);
    var newName = base.substr(0, base.length - extension.length) + SUBEXTENSION + extension;
    return path.join(directory, newName);
};

/**
 * Traverse the SpiderMonkey AST node, calling `iteratee` on `node` and its
 * children.
 */
var traverse = function traverse(node, iteratee) {
    iteratee(node);
    _.forOwn(node, function (child) {
        if (_.isObject(child)) {
            if (_.isArray(child)) {
                _.forEach(child, function (node) {
                    traverse(node, iteratee);
                });
            } else {
                traverse(child, iteratee);
            }
        }
    });
};

/**
 * Current the only directive is the Use Strict Directive (14.1.1).
 */
var DIRECTIVES = ['use strict'];

/**
 * Replace all instances of dot property assignment with bracket notation
 * assignment in `rawCodeString`. Return a transformed and formatted version of
 * the code.
 */
var transformCode = function (rawCodeString) {
    var ast = esprima.parse(rawCodeString);
    var propertyNames = [];
    traverse(ast, function (node) {
        var propertyName;
        if (node.type === 'AssignmentExpression') {
            if (node.left.type === 'MemberExpression' && node.left.computed === false) {
                propertyName = node.left.property.name;
                propertyNames.push(propertyName);
                // Use bracket notation for the assignment.
                _.merge(node.left, {
                    computed: true,
                    property: {
                        type: 'Identifier',
                        name: NAMESPACE + propertyName
                    }
                });
            }
        }
    });
    // Generate "enum" variable declarations for all the strings needed for
    // bracket notation assignments.
    var declarations = _.reduce(propertyNames, function (declarations, propertyName) {
        var variableDeclarator = {
            type: 'VariableDeclarator',
            id: {
                type: 'Identifier',
                name: NAMESPACE + propertyName
            },
            init: {
                type: 'Literal',
                value: propertyName
            }
        }
        return declarations.concat(variableDeclarator);
    }, []);
    var variableDeclaration = {
        type: 'VariableDeclaration',
        declarations: declarations,
        kind: 'var'
    };
    // Find the index of the first non-directive to avoid functionally changing
    // the code (by placing code before the directive prelude, which would
    // negate any would-be directives).
    var startIndex = 0;
    _.forEach(ast.body, function (node, index) {
        if (
            node.type === 'ExpressionStatement' &&
            node.expression.type === 'Literal' &&
            _.contains(DIRECTIVES, node.expression.value)
        ) {
            startIndex = index + 1;
        } else {
            return false;
        }
    });
    // Insert the variable declaration at that safe index.
    ast.body.splice.apply(ast.body, [startIndex, 0].concat(variableDeclaration));
    return escodegen.generate(ast) + '\n'; // Add *nixy trailing newline.
};

/**
 * Create a transformed version of each file in `files`, where the transformed
 * version of "script.js" is called "script.webkitassign.js". Invoke `callback`
 * when done.
 */
var webkitAssign = function (files, callback) {
    async.each(files, function (file, callback) {
        var outputFile = getOutputFile(file);
        fs.readFile(file, {
            encoding: 'utf8'
        }, function (error, contents) {
            if (error) {
                callback(error);
            } else {
                var transformedCode = transformCode(contents);
                fs.writeFile(outputFile, transformedCode, callback);
            }
        });
    }, callback);
};

module.exports = webkitAssign;
