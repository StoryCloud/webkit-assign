'use strict';

var _ = require('lodash');
var async = require('async');
var fs = require('graceful-fs');
var path = require('path');
var recast = require('recast');
var through2 = require('through2');

/**
 * Extension to append to files to distinguish them from their original
 * versions.
 */
var SUBEXTENSION = '.webkitassign';

/**
 * Super-duper secret namespace for variables generated by this package.
 */
var NAMESPACE = '__webkitAssign__';

/**
 * Returns `file` with a subextension (to avoid overwriting that file).
 */
var getOutputFile = function (file) {
    var directory = path.dirname(file);
    var base = path.basename(file);
    var extension = path.extname(file);
    var newName = base.substr(0, base.length - extension.length) + SUBEXTENSION + extension;
    return path.join(directory, newName);
};

/**
 * Traverse the SpiderMonkey AST node, calling `iteratee` on `node` and its
 * children.
 */
var traverse = function traverse(node, iteratee) {
    iteratee(node);
    _.forOwn(node, function (child) {
        if (_.isObject(child)) {
            if (_.isArray(child)) {
                _.forEach(child, function (node) {
                    traverse(node, iteratee);
                });
            } else {
                traverse(child, iteratee);
            }
        }
    });
};

var getNumberOfLines = function (string) {
    return string.split(/\r\n|\r|\n/).length;
};

/**
 * Current the only directive is the Use Strict Directive (14.1.1).
 */
var DIRECTIVES = ['use strict'];

/**
 * Replace all instances of dot property assignment with bracket notation
 * assignment in `rawCodeString`. Return a transformed and formatted version of
 * the code.
 */
var transformCode = function (rawCodeString) {
    var ast = recast.parse(rawCodeString);
    var propertyNames = [];
    traverse(ast.program, function (node) {
        var propertyName;
        if (node.type === 'AssignmentExpression') {
            if (node.left.type === 'MemberExpression' && node.left.computed === false) {
                propertyName = node.left.property.name;
                propertyNames.push(propertyName);
                // Use bracket notation for the assignment.
                _.merge(node.left, {
                    computed: true,
                    property: {
                        type: 'Identifier',
                        name: NAMESPACE + propertyName
                    }
                });
            }
        }
    });
    // Generate "enum" variable declarations for all the strings needed for
    // bracket notation assignments.
    var declarations = _.reduce(propertyNames, function (declarations, propertyName) {
        var variableDeclarator = {
            type: 'VariableDeclarator',
            id: {
                type: 'Identifier',
                name: NAMESPACE + propertyName
            },
            init: {
                type: 'Literal',
                value: propertyName
            }
        };
        return declarations.concat(variableDeclarator);
    }, []);
    var variableDeclaration = {
        type: 'VariableDeclaration',
        declarations: declarations,
        kind: 'var'
    };
    // Find the index of the first non-directive to avoid functionally changing
    // the code (by placing code before the directive prelude, which would
    // negate any would-be directives).
    var startIndex = 0;
    var startNode;
    _.forEach(ast.program.body, function (node, index) {
        if (
            node.type === 'ExpressionStatement' &&
            node.expression.type === 'Literal' &&
            _.contains(DIRECTIVES, node.expression.value)
        ) {
            startIndex = index + 1;
            startNode = node;
        } else {
            return false;
        }
    });
    // Insert the variable declaration at that safe index.
    ast.program.body.splice.apply(
        ast.program.body,
        [startIndex, 0].concat(variableDeclaration)
    );
    var printedCode = recast.print(ast).code;
    // Remove the mysterious extraneous leading whitespace recast sometimes adds.
    printedCode = printedCode.replace(/^\s+/, '');
    // Detect when recast added a newline after or before the variable
    // declaration.
    var offendingLine, occurrence;
    if (getNumberOfLines(printedCode) > getNumberOfLines(rawCodeString)) {
        // Seek out the newline that was added. It might have been after the
        // last directive if there were any, else the end of the variable
        // declaration.
        offendingLine = startNode ?
            startNode.loc.end.line :
            1;
        occurrence = 0;
        printedCode = printedCode.replace(/\r\n|\r|\n/g, function (match) {
            occurrence += 1;
            return occurrence === offendingLine ? '' : match;
        });
    }
    return printedCode;
};

/**
 * Return a stream that pipes in a whole file's contents and pipes out
 * transformed code.
 */
var webkitAssignStream = function () {
    var contents = '';
    return through2(function (chunk, encoding, callback) {
        // `encoding` is not used here.
        /* jshint unused: true */
        contents += chunk;
        callback();
    }, function (callback) {
        var transformedCode = transformCode(contents);
        this.push(transformedCode);
        callback();
    });
};

/**
 * Create a transformed version of each file in `files`, where the transformed
 * version of "script.js" is called "script.webkitassign.js". Invoke `callback`
 * when done.
 */
var webkitAssignFiles = function (files, callback) {
    async.each(files, function (file, callback) {
        callback = _.once(callback);
        var readStream = fs.createReadStream(file, {
            encoding: 'utf8'
        });
        var transformStream = webkitAssignStream();
        var outputFile = getOutputFile(file);
        var writeStream = fs.createWriteStream(outputFile);
        readStream
            .on('error', callback)
            .pipe(transformStream)
            .on('error', callback)
            .pipe(writeStream)
            .on('error', callback)
            .on('close', callback);
    }, callback);
};

var webkitAssign = function (codeOrFiles, callback) {
    if (_.isArray(codeOrFiles)) {
        var files = codeOrFiles;
        webkitAssignFiles(files, callback);
    } else if (arguments.length === 0) {
        return webkitAssignStream();
    }
};

module.exports = webkitAssign;
